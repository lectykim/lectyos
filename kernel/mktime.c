#include <time.h>

/*
library로서 사용하기는 힘들다. 왜냐하면, 타임존과 1970년 이전의 시간에
대해서는 커버하지 않기 때문. 
*/
#define MINUTE 60
#define HOUR (60*MINUTE)
#define DAY (24*HOUR)
#define YEAR (365*DAY)
//윤년을 포함한다.
static int month[12] = {
    0,
    DAY*(31),
    DAY*(31+29),
    DAY*(31+29+31),
    DAY*(31+29+31+30),
    DAY*(31+29+31+30+31),
    DAY*(31+29+31+30+31+30),
    DAY*(31+29+31+30+31+30+31),
    DAY*(31+29+31+30+31+30+31+31),
    DAY*(31+29+31+30+31+30+31+31+30),
    DAY*(31+29+31+30+31+30+31+31+30+31),
    DAY*(31+29+31+30+31+30+31+31+30+31+30)
};
long kernel_mktime(struct tm* tm)
{
    //32비트 컴퓨터에서의 long = 2^32 = 64bit 컴퓨터에서의 int값이다.
    long res;
    int year;
    /*
    cmos에서 가져온 연수 데이터는, 1900년 이후 지난 연수를 저장하고 있다.
    그러나 우리가 알고 싶은 건 1970년 기준으로 얼마나 지났는가이다. (Unix Epoch)
    그렇기 때문에 예를 들어 2025년이라면, 1900년부터 125년이 지났기 대문에 tm->tm_year값은 125이고,
    -70을 적용하면 55로, unix epoch값이 나오게 된다.
    */
    year = tm->tm_year - 70;
    /*
    이제 365일 * 연수 + 윤년 수(매 4년마다 1일 추가하기)를 계산할 때, 올바르게 작동되게 된다.
    왜냐하면 윤년의 경우에는 4로 나누었을 때를 기점으로 하나,
    2038년에 overflow로 time_t가 터지기 때문에 2100년의 edgecase를 토발즈는 고려하지 않은 것으로 보인다.

    그럼 밑에는 윤년을 구하는 데 2를 더했고,
    위에는 1을 더한 이유는 무엇일까?
    197'2'년 1월에는 윤년을 더할 필요가 없고,
    197'2'년 2월에는 윤년을 더할 필요가 있다.
    그러나 윤년에 1을 더하는 코드는 month[12]에서 이미 구현이 되어 있으므로,
    당해의 연도에 대한 윤년을 더하는 로직은 준비가 되어 있다.
    이 코드에서 우리가 필요한 부분은 '지난' 윤년에 대한 플러스 로직이므로 여기선 플러스 1, 밑에선 플러스 2인 것.
    */
    res = YEAR*year + DAY*((year+1)/4);
    res += month[tm->tm_mon];
    /*
    우리가 month를 무조건 29일로 표기해놨기 때문에,
    윤년이 아닌 때라면 -1을 해주는 트릭.
    왜냐면 1972년부터 4년에 한 번씩 윤년이 찾아오기 때문.
    */
    if(tm->tm_mon>1 && ((year+2)%4))
        res -= DAY;

    res += DAY*(tm->tm_mday-1);
    res += HOUR*tm->tm_hour;
    res += MINUTE*tm->tm_min;
    res += tm->tm_sec;
    return res;
}